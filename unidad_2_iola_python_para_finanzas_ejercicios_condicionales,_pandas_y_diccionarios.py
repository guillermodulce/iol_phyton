# -*- coding: utf-8 -*-
"""Unidad 2: IOLA Python para finanzas - Ejercicios Condicionales, pandas y diccionarios.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1ZMQpg0-CxuwUUko79kOdZ8EMewww8Dtd

# Guia de ejercicios: diccionarios, condicionales y dataframes intro
**Profesor**: Ignacio Guardines
<br>
**telegram | twitter** :@nacho_java

#Ejercicio 1

dado el siguiente diccionario que representa un trade en un sistema, se pide:
- intentar obtener por medio de ["noexiste"] el valor de la clave "noexiste".
- ver que pasa con el metodo get("noexiste")
"""

trade =  {
          "price":15.77,
          "size":125,
          "datetime":"2017-05-17 14:29:24.831",
          "servertime":1495031364831,
          "symbol":"DOMay21"
        }





#posible solucion
#1 ·este va a tirar error y es lo esperado (para este ejercicio)
trade["noexiste"]

trade.get("noexiste")

"""#Ejercicio 2

Dado el siguiente diccionario guardar en una variable:
- el valor del status
- el symbol (ticker)
- el precio y size del 2do trade
"""

resultado = {
    "status":"OK",
    "symbol":"DOMay21",
    "market":"ROFX",
    "trades":[
        {
        "price":15.77,
        "size":125,
        "datetime":"2017-05-17 14:29:24.831",
        "servertime":1495031364831,
        "symbol":"DOMay21"
        },
        {
        "price":15.775,
        "size":75,
        "datetime":"2017-05-17 14:35:40.152",
        "servertime":1495031740152,
        "symbol":"DOMay21"
        },
        {
        "price":15.76,
        "size":325,
        "datetime":"2017-05-17 14:46:43.038",
        "servertime":1495032403038,
        "symbol":"DOMay21"
        },
        {
        "price":15.73,
        "size":1000,
        "datetime":"2017-05-17 15:54:15.700",
        "servertime":1495036455700,
        "symbol":"DOMay21"
        }
    ]
}







# posible resultado
status = resultado.get("status")
ticker = resultado.get("symbol")

segundo_trade = resultado.get("trades")[1]

print(f"el status es {status} ticker {ticker} y los valores del segundo trade, precio {segundo_trade['price']}, tamaño {segundo_trade['size']}")

"""# Ejercicio 3
Dado el la siguiente lista que contiene trades, se necesita saber el acumulado de los totales,poner un total por default en 0 cuando este, no esté presente.


"""

trades =[{
        "total":15.77,
        "datetime":"2017-05-17 14:29:24.831",
        "servertime":1495031364831,
        "symbol":"DOMay21"
        },
        {
        "total":1500,
        "datetime":"2017-05-17 14:35:40.152",
        "servertime":1495031740152,
        "symbol":"DOMay21"
        },
        {
        "total":31.14,
        "size":325,
        "datetime":"2017-05-17 14:46:43.038",
        "servertime":1495032403038,
        "symbol":"DOMay21"
        },
        {
        "size":325,
        "datetime":"2017-05-17 14:46:43.038",
        "servertime":1495032403038,
        "symbol":"DOMay21"
        }
    ]







#posible solución
total = 0
for trade in trades:
  total += trade.get("total", 0)

print(f"el total acumulado es {total} ")



"""# Ejercicio 4
Dado el siguiente diccionario se necesita saber del primer nivel:
- cuales son los keys
- cuales son los values.
- obtener los items
- de que tipo son cada una de las cosas solicitadas previamente?
- convertirlos a una lista
"""

trades = {
    "status":"OK",
    "symbol":"DOMay21",
    "market":"ROFX",
    "trades":[
        {
        "price":15.77,
        "size":125,
        "datetime":"2017-05-17 14:29:24.831",
        "servertime":1495031364831,
        "symbol":"DOMay21"
        },
        {
        "price":15.775,
        "size":75,
        "datetime":"2017-05-17 14:35:40.152",
        "servertime":1495031740152,
        "symbol":"DOMay21"
        },
        {
        "price":15.76,
        "size":325,
        "datetime":"2017-05-17 14:46:43.038",
        "servertime":1495032403038,
        "symbol":"DOMay21"
        },
        {
        "price":15.73,
        "size":1000,
        "datetime":"2017-05-17 15:54:15.700",
        "servertime":1495036455700,
        "symbol":"DOMay21"
        }
    ]
}





#posible solucion
print(list(trades.keys()))
print(trades.values())
print(trades.items())



"""# ejercicio 5
Iterando un diccionario
Dado el siguiente diccionario, iterar y mostrar:
- las claves del primer nivel
- Los valores del primer nivel
- ambas cosas por medio del items() hacerlo empaquetado en una variable como desempaquetando convenientemente en dos.
- De que tipo es el valor de lo que contiene la clave trade?
- buscar las claves de dicho diccionario.
"""

diccionario = {
    "status":"OK",
    "symbol":"DOMay21",
    "market":"ROFX",
    "trade":
        {
        "price":15.77,
        "size":125,
        "datetime":"2017-05-17 14:29:24.831",
        "servertime":1495031364831,
        "symbol":"DOMay21"
        }
}







#posible solucion

for clave in diccionario.keys():
    print(clave)

# itero un objeto empaquetado
for item in diccionario.items():
    print(item)

# itero un objeto empaquetado
for item in diccionario.items():
    print(item[1])

# desempaquetado e iterado
for clave, valor in diccionario.items():
    print(f'el ticker {clave} tiene precio $ {valor}')

"""# Ejercicio 6
 La función zip()

 Dadas dos listas (una representan tickers y la otra representan precios) con correspondencia posicional entre sus elementos, zippear ambas listas y pasarlas a un dicionario a fin de que quede como un panel, al que se accede por medio de cada ticker como key y el precio es el valor (value)
"""







#posible solucion
tickers = ['GRAF','VIBR','NANO', 'ANTI']
precios = [1000000000,5000000000,1200000000, 60000000000000]

diccio = dict(zip(tickers,precios))
diccio

"""# Ejercicio 7
Escribir los numeros de la lista de precios = [1000000000,5000000000,1200000000, 60000000000000]
En un formato mas legible

# Ejercicio 8

Centauros, Unicornios y demases
Los centauros son la denominacion qu estan recibiendo aquellas empresas de mas de 100_000_000 de dolares.por otro lado estan los unicornios aquellas que superan los mil millones.
Definir dos constantes una MONTO_CENTAURO y la analoga para los unicornios
asignarle los valores correspondientes, o cota inferior

- Probar las diferentes formas de escritura de los numeros grandes.
- el programa debera dado un numero de valuacion de una empresa mostrar por pantalla si es centauro, unicornio u otro.
"""







#posible solucion

#diferentes formas de escribir un numero grande
nro = 12000000000
nro = 12_000_000_000
nro = 12*10**9
nro = 12e9

MONTO_CENTAURO = 10e7
MONTO_UNICORNIO = 10e9



"""#Ejercicio 9

Dadas dos listas, una de ticker y la otra de montos(ambas con relacion uno a uno posicionalmente) osea un ticker un monto, que representan una cartera, crear un dataframe con los tickers y luego agregar una columna montos y asignarle la lista montos
"""







#Posible solucion
import pandas as pd
tickers = ['ACTIVO1','ACTIVO2','ACTIVO3','ACTIVO4','ACTIVO7','ACTIVO6']
montos = [12500, 5000, 10_500, 20_000, 7*10**3, 25e3]

cartera = pd.DataFrame( index=tickers)
cartera['montos'] = montos
cartera

"""# Ejercicio 10

con el planteo del ejercicio anterior y por medio del metodo sum() obtener el suma total de los montos.
"""





#solucion
cartera.sum()

"""#Ejercicio 11

Se necesita agregar una columna mas llamada "compra" todos sus valores deben estar en falso.
"""







#posible solucion+

cartera["compra"] = False
cartera

"""# Ejercicio 12

Con la cartera del ejercicio anterior se pide ahora crear una columna mas, llamada porcentaje que determine el porcentaje ponderado de cada monto respecto del total


"""







#Posible solucion
import pandas as pd
tickers = ['ACTIVO1','ACTIVO2','ACTIVO3','ACTIVO4','ACTIVO7','ACTIVO6']
montos = [12500, 5000, 10_500, 20_000, 7*10**3, 25e3]

cartera = pd.DataFrame( index=tickers)
cartera['montos'] = montos
cartera["compra"] = False

cartera['porcentajes'] = cartera.montos / cartera.montos.sum()
cartera



"""#Ejercicio 13
Ordenar y mostrar los porcentajes de mayor a menor 
"""





#Solucion
cartera.porcentajes.sort_values(ascending=False)

"""# Ejercicio 14
Ordenar de mayor a menor y mostrar los primeros 3
"""





#Posible solucion
cartera.montos.sort_values(ascending=False).head(3)

"""# Ejercicio 15
Ordenar de mayor a menor y mostrar los ultimos 3
"""





#posible solucion
cartera.montos.sort_values(ascending=False).tail(3)

"""# Ejercicio 16

- Instalar la libreria yfinance
- descargar market data de Apple
"""

# Solucion

!pip install yfinance
import yfinance as yf

yf.download('AAPL', auto_adjust=True)

"""# Ejercicio 17

Buscar informacion de mercado de la empresa microsoft por medio de yfinance desde 2005
"""

# Solucion

!pip install yfinance
import yfinance as yf

yf.download('MSFT', start='2005-01-01')

yf.download('AAPL', start='2021-02-01', interval='5m', auto_adjust=True)

"""#Ejercicio 18

Crear una lista de activos a buscar y por medio de yfinance, buscarlos y solicitar market data desde comienzos del 2021
"""





#Posible solucion
tickers = ['AAPL', 'FB', 'AMZN', 'GOOGL', 'NFLX', 'QQQ', 'SQQQ']

data = yf.download(tickers, start='2021-01-01', auto_adjust=True)
data

"""# Ejercicio 19
para que sea mas claro, ahora solo limitar a que se traiga el precio de cierre
"""





# posible solucion
tickers = ['AAPL', 'FB', 'AMZN', 'GOOGL', 'NFLX', 'QQQ', 'SQQQ']

data = yf.download(tickers, start='2021-01-01', auto_adjust=True)["Close"]
data

"""# Ejercicio 20


Crear un programa que solicite por pantalla un activo, el programa debe buscar si se encuentra en una lista de activos (tambien a program), mostrar si esta o no en la cartera.
"""







#posible Solucion
ticker = input("Por favor ingrese el activo a buscar en cartera")
cartera = ["AAPL","AMZN","FB"]

if ticker in cartera:
    print(f"{ticker} está en la cartera")

else:
    print(f"{ticker} NO está en la cartera")

"""# Ejercicio 21

Crear un programa que muestre si un activo en particular se encuentra en una cartera.
en el caso que esté, verificar si hay una determinada cantidad de nominales a fin de efectuar una venta
"""

cartera = ["AAPL","AMZN","FB"]
nominales = [1000, 500, 200]





#posible solucion
accion = "BTC"
cartera = ["AAPL","AMZN","FB"]
nominales = [1000, 500, 200]

if accion in cartera:
    indice = cartera.index(accion)
    print(f" posee la accion {accion} ")

else:
    print(F"{accion} NO está en la cartera")



"""#Ejercicio 22

Escribir un programa qeu dada una cartera, confirme que una accion determinada no se encuentra en la misma, (en el else no hacer nada)
"""







#posible solucion
accion = "API"
cartera = ["AAPL","AMZN","FB"]

if accion not in cartera:
    print(f"la accion {accion} no está en la cartera")
else:
    pass

"""# Ejercicio 23

Dado una lista de 4 resistencias de menor a mayor, codificar un programa que pregunte un precio y segun el precio, muestre por pantalla la proxima resistencia inmediata.
"""

#Posible solucion

resistencias = [7,10,15,20]
precio = float(input("Ingresar el precio: "))

if precio < resistencias[0]:
    print("Resistencia a vencer: ", resistencias[0])
    
elif precio < resistencias[1]:
    print("Resistencia a vencer: ", resistencias[1])
    
elif precio < resistencias[2]:
    print("Resistencia a vencer: ", resistencias[2])
    
elif precio < resistencias[3]:
    print("Resistencia a vencer: ", resistencias[3])  
    
else:
    print("Estamos en máximos históricos")

# solucion con variante de for
resistencias = [7,10,15,20]
precio = float(input("Ingresar el precio: "))

for resistencia in resistencias:
    if precio < resistencia:
        print("Resistencia a vencer: ", resistencia)
        break









"""#Ejercicio 24

Solicitar por pantalla el ingreso de un precio de compra y establecerse el stop loss de -2% y un take profit de 5%, luego ingresar el precio y por medio de condiciones el programa debe poder decidir si vender o mantener, debajo del sl es venta no immporta cuan abajo, por arriab del take profit es venta,y en elos extremos entre stop loss y take profit es hold.
"""







#Posible Solucion

precio = float(input("Ingresar precio actual: "))
stopLoss = precio * 0.98
takeProfit = precio * 1.05


precio = float(input("Ingresar precio compra: "))
if precio > stopLoss:
    if precio < takeProfit:
        print("Hold")
    else:
        print("Salida por take Profit")
else:
    print("Salida por Stop Loss")

"""# Ejercicio 25
Crear un reloj que muestre el instante actual de tiempo con un segundo de espera.
"""







#posible solucion 

import time, datetime

while True:
    print("ahora es: ", datetime.datetime.now())
    time.sleep(1)

"""# Ejercicio 26
 limitar al ejercicio anterior con una condicion de corte por ej, que se imprima 10 veces
"""







#posible solucion
import time, datetime

i = 0
while True:
    print("Cada un segundo imprimo fecha/hora: ", datetime.datetime.now())
    time.sleep(1)
    i += 1
    if i>5:
        break
        print('Salida por break')